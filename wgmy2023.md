# Wargames.my 2023 - Writeup
A year had passed since my [last participation](https://github.com/rixinsc/ctf-writeups/blob/master/wgmy2022.md) in wgmyCTF so this is my fourth wgmyCTF all time, and the second time in student category.
The quality of challenge improved a lot this year. With just right difficulties and almost no guessy challenges, it was a well organised CTF.

I am going by the team of `GPT-110` this time, with old and new friends. Our rank is a little lower than last year but it was still a good experience nevertheless.
Many of the challenges are multi-stage, with rabbit holes waiting to trap us players. I'd say they're quite tricky but I guess it was a chance for me to learn to be patient, as many times I took a few hours just to solve a challenge.

### The other writeup: https://github.com/Jurf3d/CTF/blob/main/WGMY%202023/WGMY%202023%20Writeup.pdf

## Table of Contents
- [**Web**](#web)
    - [**Warmup - Web** - JS Deobfuscation + PHP LFI](#warmup---web)
    - [**Pet Store Viewer** - Format String Vulnerability](#pet-store-viewer)
    - [**My First AI Project** - Pickle Insecure Deserialisation](#my-first-ai-project)
- [**Misc**](#misc)
    - [**Warmup - Game** - Unity EXE Reverse](#warmup---game)
    - [**Sayur** - LSB Image Steganography](#sayur)
- [**Crypto**](#crypto)
    - [**N-less RSA** - RSA without N](#n-less-rsa)
- [**Forensic**](#forensic)
    - [**Compromised** - RDP Bitmap Cache](#compromised)
- [**Pwn**](#pwn)
    - [**Magic Door** - ret2libc](#magic-door)
- [**PPC**](#ppc)
    - [**Linux Memory Usage**](#linux-memory-usage)
    - [**Lokami Temple**](#lokami-temple)
- [**Unsolved Challenges** (Other writeups)](#unsolved-challenges)

## Web
### Warmup - Web
> Let's warm up! http://warmup.wargames.my

[*Back to top*](#table-of-contents)

#### Getting the Password
To get the password, we can first set a breakpoint on the `onclick` handler of the button. Tracing the call down to an object referenced in an if statement reveals the correct password it's comparing to.<br>
![image](https://github.com/rixinsc/ctf-writeups/assets/37703689/b442bd47-638c-4037-a730-66fe18d4c90e)

Password: `this_password_is_so_weak_i_can_crack_in_1_sec!`

#### Discovering LFI
After entering the correct password, a success alert box is shown with a text that reads `Here's your flag`. Upon closer inspection, we can see that the text is read from a web API `api/4aa22934982f984b8a0438b701e8dec8.php?x=flag_for_warmup.php`.<br>
![image](https://github.com/rixinsc/ctf-writeups/assets/37703689/4249a452-c9b1-4d0f-99a8-ed56b6e87505)<br>
Since changing the `x` parameter to `../../../etc/passwd` reveals the passwd file, we can confirm this is a LFI vulnerability.

#### Exploitation
The text hints that the flag is likely hidden within the comment of the php file, so we need to find a way to read the php source code. Based on experience, php supports [many kinds of stream filters](https://www.php.net/manual/en/filters.php) that can tamper with input file before they're returned to the reader. <br>
Several basic attempts showed that the most common filters are blocked by a word blacklist. With multiple trial and error, it's found that the `zlib.defalte` filter is not blocked. So we employ it to modify our file stream and get the php file back in zlib compressed form.<br>
![image](https://github.com/rixinsc/ctf-writeups/assets/37703689/5102cf09-8b32-45cc-9702-95d72311e739)<br>
After we got it, we can run a php instance to decode it using the `zlib_decode` function, and get the flag.

### Pet Store Viewer
> Explore our online pet store for adorable companions – from playful kittens to charming chickens. Find your perfect pet today. Buy now and bring home a new friend!

[*Back to top*](#table-of-contents)
<details>
<summary>Source of <code>app.py</code></summary>

```py
from flask import Flask, render_template, url_for ,request
import os
import defusedxml.ElementTree as ET

app = Flask(__name__)

CONFIG = {
    "SECRET_KEY" : os.urandom(24),
    "FLAG" : open("/flag.txt").read()
}

app.secret_key = CONFIG["SECRET_KEY"]

class PetDetails: 
    def __init__(self, name, price, description, image_path, gender, size): 
        self.name = name 
        self.price = price 
        self.description = description 
        self.image_path = image_path 
        self.gender = gender 
        self.size = size 

def parse_store_xml_file(xml_file="store.xml"):
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()

        items = []
        for item_element in root.findall('item'):
            name = item_element.find('name').text
            price = float(item_element.find('price').text)
            description = item_element.find('description').text
            image_path = item_element.find('image_path').text
            gender = item_element.find('gender').text
            size = item_element.find('size').text

            item_data = (name, price, description, image_path, gender, size)
            items.append(item_data)

        return items
    except ET.ParseError as e:
        print(f"Error parsing XML: {e}")
    return None

def parse_xml(xml):
    try:
        tree = ET.fromstring(xml)
        name = tree.find("item")[0].text
        price = float(tree.find("item")[1].text)
        description = tree.find("item")[2].text
        image_path = tree.find("item")[3].text
        gender = tree.find("item")[4].text
        size = tree.find("item")[5].text
        details = PetDetails(name,price,description,image_path,gender,size)
        combined_items = ("{0.name};"+str(details.price)+";{0.description};"+details.image_path+";{0.gender};{0.size}").format(details)
        return [combined_items]
    except Exception as e:
        app.logger.error("Malformed xml, skipping")
        app.logger.error(e)
        return []

# Index
@app.route('/')
def index():
    return render_template('index.html',value=parse_store_xml_file())

@app.route('/view')
def view():
    xml = request.args.get('xml')
    list_results = parse_xml(xml)
    if list_results:
        items = list_results[0].split(";")
        return render_template('view.html',value=items)
    else:
        return render_template('error.html')

# Main Function
if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0")
```
</details>

We are presented with a webpage that reads data from XML and render them in a [jinja2 template](https://flask.palletsprojects.com/en/2.3.x/templating/) with [Flask](https://flask.palletsprojects.com/).<br>
Obviously the first thing we would try is some [XXE techniques](https://book.hacktricks.xyz/pentesting-web/xxe-xee-xml-external-entity) but since [`defusedxml`](https://pypi.org/project/defusedxml/) by default [forbid entities declaration](https://github.com/tiran/defusedxml#:~:text=instruction%20is%20found.-,forbid_entities,-(default%3A%20True)), an exception will be thrown. [Template injection](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection/jinja2-ssti) is also not possible because `render_template` is only called on static html file.<br>

After many hours of frustration, finally we notice that in line 55, the data string is concatenated with user input (`image_path`) before it is used with `str.format` function to format. Double substitution in this order creates an interesting vulnerability named [format string vulnerability](https://security.stackexchange.com/a/239661/235815).<br>
To exploit this, we can simply substitute `image_path` with `{0.__init__.__globals__}` to get all global variables which also contain the flag.
![image](https://github.com/rixinsc/ctf-writeups/assets/37703689/31003e8b-0da1-48b5-8a02-c61a35c8e415)

### My First AI Project
> Explore my beginner-friendly web UI for testing an AI project!

[*Back to top*](#table-of-contents)

To start off, we leak the app source code by loading the source code as "model", where the handy preview function shows us the file content.<br>
In the source code, we can see that the upload function is actually implemented partially, and we can upload files to the server despite not being able to train with valid datasets. Also in the function that loads a model, the `np.load` function is explicitly configured to allow pickles, which is an insecure deserialisation format.<br>
By using this, we can upload a malicious pickle file in `.csv` extension to the server then load it using the load model function. The malicious pickle file can be used to rename the flag file name to bypass the waf, then we can easily read the flag.

## Misc
### Warmup - Game
> It's cold, we need to warmup

[*Back to top*](#table-of-contents)


#### Unpack
We are provided with a simple game made using Unity game engine (as evidenced by the logo and the splash).<br>
Unity executables usually come with dll and asset files, but we only have one executable file this time. To answer this, we load the executable in dnSpy, which revealed that a [packer](https://github.com/SerGreen/Appacker) is involved.<br>
![image](https://github.com/rixinsc/ctf-writeups/assets/37703689/5dbac3ca-60ca-4598-9e17-d4b5e69c7483)<br>
To proceed, we set a breakpoint on the unpack function to find out where it unpacks (somewhere random in `%TEMP%` folder) and copy all the unpacked files out.

#### Reverse
Now that we have all the normal Unity files, customarily we inspect them using a Unity asset extraction tool such as [UABEA](https://github.com/nesrak1/UABEA).<br>
Most of the important game assets are in the `data.unity3d` file. Within the `level0` scene, there's a GameObject named `TrueRoom` which is suspicious enough.
Viewing the only text GameObject inside reveals the flag in base64 format. <br>
![image](https://github.com/rixinsc/ctf-writeups/assets/37703689/be35a5a6-45d3-443b-b369-a31fe1f509b8)


### Sayur
> Sayur Kemudian Lebih Latih

[*Back to top*](#table-of-contents)

This time we only got a png image, analysing the image through [stegsolve](http://www.caesum.com/handbook/Stegsolve.jar) reveals that there's data encoded within plane 0 and 1 of each colour channel. This hints that the image could be LSB 2-bit encoded.
![image](https://github.com/rixinsc/ctf-writeups/assets/37703689/91db788a-f8d3-4b35-94bf-75b2d9db93b1)

Running [`zsteg`](https://github.com/zed-0xff/zsteg) through the image reveals there's valid text data when arranging the bits by row in rgba order. We use `zsteg sayur.png -E b2,rgba,lsb,xy > extracted.txt` to extract all the text out.<br>
Lastly through trial and error, we produce a script to decode the text by transforming the signature phrase 菜就多练 in various language into base 4 bits, and finally obtain the flag after 3 rounds.

<details>
<summary>Solution script for Sayur</code></summary>

```py
from Crypto.Util.number import long_to_bytes

with open("extracted.txt", 'r', encoding='utf-8') as f:
    bits = f.read()

bits = bits.replace('Sayur', '0').replace('Kemudian', '1').replace("Banyak", '2').replace("Latih", '3')
bits = long_to_bytes(int(bits, 4)).decode().replace('Vegetable', '0').replace('Then', '1').replace("Many", '2').replace("Practice", '3')
bits = long_to_bytes(int(bits, 4)).decode().replace('菜', '0').replace('就', '1').replace("多", '2').replace("练", '3')

print(long_to_bytes(int(bits, 4)).decode())
```
</details>

## Crypto
### N-less RSA
> Endless RSA?

[*Back to top*](#table-of-contents)

A [similar](https://ctftime.org/writeup/33119) writeup was found. By modifying it with the appropriate parameters we get the flag.

## Forensic
### Compromised
> Where aRe you?

[*Back to top*](#table-of-contents)

Searching `Cache0000.bin` reveals the cache vulnarability. [A script](https://github.com/Viralmaniar/Remote-Desktop-Caching-/blob/master/rdpcache.ps1) is employed to extract the cache images then we use that to guess the password and decompress the zip file.

## Pwn
### Magic Door
> Knock Knock open the door please

Solved by teammate, refer [here](https://github.com/Jurf3d/CTF/blob/main/WGMY%202023/WGMY%202023%20Writeup.pdf).
[*Back to top*](#table-of-contents)

## PPC
### Linux Memory Usage
[*Back to top*](#table-of-contents)

To solve this problem, we need to build a tree-like structure representing the relationships between processes and their parents. Then, for each query, calculate the total memory usage of the specified process and all its descendants.

```py
from collections import defaultdict

def calculate_memory_usage(process_id, process_tree, process_memory):
    total_memory = process_memory[process_id]

    for child_id in process_tree[process_id]:
        total_memory += calculate_memory_usage(child_id, process_tree, process_memory)

    return total_memory

def main():
    # Input reading
    N, Q = map(int, input().split())
    process_tree = defaultdict(list)
    process_memory = {}

    for _ in range(N):
        pid, ppid, mem = map(int, input().split())
        process_tree[ppid].append(pid)
        process_memory[pid] = mem

    # Process queries
    for _ in range(Q):
        query_pid = int(input())
        total_memory = calculate_memory_usage(query_pid, process_tree, process_memory)
        print(total_memory)

if __name__ == "__main__":
    main()
```

**But time limit exceeds!**

Since it did not set limit according to language, so I optimize the program by storing the total memory usage for each process during the tree traversal and avoiding redundant calculations and rewrite it using C++

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

unordered_map<int, vector<int>> process_tree;
unordered_map<int, int> process_memory;
unordered_map<int, int> memo;

int calculate_memory_usage(int process_id) {
    if (memo.find(process_id) != memo.end()) {
        return memo[process_id];
    }

    int total_memory = process_memory[process_id];

    for (int child_id : process_tree[process_id]) {
        total_memory += calculate_memory_usage(child_id);
    }

    memo[process_id] = total_memory;
    return total_memory;
}

int main() {
    // Input reading
    int N, Q;
    cin >> N >> Q;

    for (int i = 0; i < N; ++i) {
        int pid, ppid, mem;
        cin >> pid >> ppid >> mem;
        process_tree[ppid].push_back(pid);
        process_memory[pid] = mem;
    }

    // Process queries
    for (int i = 0; i < Q; ++i) {
        int query_pid;
        cin >> query_pid;
        int total_memory = calculate_memory_usage(query_pid);
        cout << total_memory << endl;
    }

    return 0;
}
```

Then, we did it!

### Lokami Temple
Solved by teammate, refer [here](https://github.com/Jurf3d/CTF/blob/main/WGMY%202023/WGMY%202023%20Writeup.pdf).
[*Back to top*](#table-of-contents)

# Unsolved Challenges

[*Back to top*](#table-of-contents)
